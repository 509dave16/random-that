{"version":3,"sources":["webpack:///webpack/bootstrap 5de73f55227d5071a76e","webpack:///./src/index.ts","webpack:///./~/inferno-dom/inferno-dom.js","webpack:///./~/inferno/dist/inferno-dom.js","webpack:///./~/inferno-component/inferno-component.js","webpack:///./~/inferno/dist/inferno-component.js","webpack:///./~/inferno-create-element/inferno-create-element.js","webpack:///./~/inferno/dist/inferno-create-element.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrCA,yCAAuB,CAAa,CAAC;AACrC,+CAAsB,CAAmB,CAAC;AAC1C,oDAAiB,CAAwB,CAAC;AAE1C,KAAM,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;AAEjD;KAA0B,+BAAS;KAAnC;SAA0B,8BAAS;KAInC,CAAC;KAHA,4BAAM,GAAN;SACC,MAAM,CAAC,gCAAI,CAAC,KAAK,EAAE,IAAI,EAAE,cAAc,CAAC,CAAC;KAC1C,CAAC;KACF,kBAAC;AAAD,EAAC,CAJyB,2BAAS,GAIlC;AAED,qBAAM,CAAC,gCAAI,CAAC,WAAW,CAAC,EAAE,SAAS,CAAC,CAAC;;;;;;;ACbrC;;AAEA,yC;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,oBAAoB;;AAErB;AACA;AACA;AACA;AACA;AACA,8BAA6B,UAAU,qBAAqB;AAC5D,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,iBAAiB;AACnC;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,qBAAqB;AACxC;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2CAA0C,0BAA0B,EAAE;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAsC,SAAS;AAC/C;AACA;AACA,IAAG;AACH;AACA;AACA,kDAAiD,aAAa;AAC9D;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qDAAoD;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,4EAA2E;AAC3E;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,uGAAsG,uBAAuB;AAC7H;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,QAAO;AACP;AACA;AACA,SAAQ;AACR;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,0EAAyE;AACzE;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,wGAAuG,sBAAsB;AAC7H;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAkB,oBAAoB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB,wBAAwB;AAC5C;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA,oBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA,qBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,qBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB,4BAA4B;AACjD;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,kBAAkB;AAC1B;AACA;;AAEA;AACA;AACA;AACA,0BAAyB,wBAAwB;AACjD;;AAEA;AACA;AACA,IAAG;AACH,0BAAyB,wBAAwB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,gCAAgC;AAC1C;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,eAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA,mCAAkC,uBAAuB;AACzD;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA,6BAA4B,mBAAmB;AAC/C;AACA;AACA,6BAA4B,mBAAmB;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,KAAI;AACJ,0BAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,cAAc;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;;AAEA,mBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA,mBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gDAA+C;AAC/C,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,sBAAqB;AACrB;;AAEA;AACA,uBAAsB,qBAAqB;AAC3C;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,SAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA,2BAA0B,eAAe;AACzC;AACA,IAAG;AACH;AACA,qEAAoE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC,G;;;;;;ACx/DD;;AAEA,yC;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,oBAAoB;;AAErB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2CAA0C,0BAA0B,EAAE;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;;AAEA,mBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,sCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAa,OAAO;AACpB;;AAEA,cAAa,OAAO;AACpB;;AAEA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC,G;;;;;;AC/QD;;AAEA,yC;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,oBAAoB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAsB,6CAA6C;AACnE;;AAEA;;AAEA,EAAC,G","file":"./dist/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5de73f55227d5071a76e\n **/","import Inferno from 'inferno';\nimport { render } from 'inferno-dom';\nimport Component from 'inferno-component';\nimport elem from 'inferno-create-element';\n\nconst container = document.getElementById('app');\n\nclass MyComponent extends Component {\n\trender() {\n\t\treturn elem('div', null, 'Hello world!');\n\t}\n}\n\nrender(elem(MyComponent), container);\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.ts\n **/","'use strict';\r\n\r\nmodule.exports = require('inferno/dist/inferno-dom');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inferno-dom/inferno-dom.js\n ** module id = 1\n ** module chunks = 0\n **/","/*!\n * inferno-dom v0.7.25\n * (c) 2016 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.InfernoDOM = factory());\n}(this, function () { 'use strict';\n\n\tfunction addChildrenToProps(children, props) {\n\t\tif (!isNullOrUndefined(children)) {\n\t\t\tvar isChildrenArray = isArray(children);\n\t\t\tif (isChildrenArray && children.length > 0 || !isChildrenArray) {\n\t\t\t\tif (props) {\n\t\t\t\t\tprops = Object.assign({}, props, { children: children });\n\t\t\t\t} else {\n\t\t\t\t\tprops = {\n\t\t\t\t\t\tchildren: children\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn props;\n\t}\n\n\tvar NO_RENDER = 'NO_RENDER';\n\n\t// Runs only once in applications lifetime\n\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\n\tfunction isArray(obj) {\n\t\treturn obj instanceof Array;\n\t}\n\n\tfunction isStatefulComponent(obj) {\n\t\treturn obj.prototype && obj.prototype.render !== undefined;\n\t}\n\n\tfunction isStringOrNumber(obj) {\n\t\treturn isString(obj) || isNumber(obj);\n\t}\n\n\tfunction isNullOrUndefined(obj) {\n\t\treturn isUndefined(obj) || isNull(obj);\n\t}\n\n\tfunction isInvalidNode(obj) {\n\t\treturn isNull(obj) || obj === false || obj === true || isUndefined(obj);\n\t}\n\n\tfunction isFunction(obj) {\n\t\treturn typeof obj === 'function';\n\t}\n\n\tfunction isString(obj) {\n\t\treturn typeof obj === 'string';\n\t}\n\n\tfunction isNumber(obj) {\n\t\treturn typeof obj === 'number';\n\t}\n\n\tfunction isNull(obj) {\n\t\treturn obj === null;\n\t}\n\n\tfunction isTrue(obj) {\n\t\treturn obj === true;\n\t}\n\n\tfunction isUndefined(obj) {\n\t\treturn obj === undefined;\n\t}\n\n\tfunction deepScanChildrenForNode(children, node) {\n\t\tif (!isInvalidNode(children)) {\n\t\t\tif (isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tvar child = children[i];\n\n\t\t\t\t\tif (!isInvalidNode(child)) {\n\t\t\t\t\t\tif (child === node) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else if (child.children) {\n\t\t\t\t\t\t\treturn deepScanChildrenForNode(child.children, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (children === node) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (children.children) {\n\t\t\t\t\treturn deepScanChildrenForNode(children.children, node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction getRefInstance$1(node, instance) {\n\t\tvar children = instance.props.children;\n\n\t\tif (deepScanChildrenForNode(children, node)) {\n\t\t\treturn getRefInstance$1(node, instance._parentComponent);\n\t\t}\n\t\treturn instance;\n\t}\n\n\tvar recyclingEnabled = true;\n\n\tfunction recycle(node, bp, lifecycle, context, instance) {\n\t\tif (bp !== undefined) {\n\t\t\tvar pool = bp.pool;\n\t\t\tvar recycledNode = pool.pop();\n\n\t\t\tif (!isNullOrUndefined(recycledNode)) {\n\t\t\t\tpatch(recycledNode, node, null, lifecycle, context, instance, bp.isSVG);\n\t\t\t\treturn node.dom;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction pool(node) {\n\t\tvar bp = node.bp;\n\n\t\tif (!isNullOrUndefined(bp)) {\n\t\t\tbp.pool.push(node);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction unmount(input, parentDom) {\n\t\tif (isVList(input)) {\n\t\t\tunmountVList(input, parentDom, true);\n\t\t} else if (isVNode(input)) {\n\t\t\tunmountVNode(input, parentDom, false);\n\t\t}\n\t}\n\n\tfunction unmountVList(vList, parentDom, removePointer) {\n\t\tvar items = vList.items;\n\t\tvar itemsLength = items.length;\n\t\tvar pointer = vList.pointer;\n\n\t\tif (itemsLength > 0) {\n\t\t\tfor (var i = 0; i < itemsLength; i++) {\n\t\t\t\tvar item = items[i];\n\n\t\t\t\tif (isVList(item)) {\n\t\t\t\t\tunmountVList(item, parentDom, true);\n\t\t\t\t} else {\n\t\t\t\t\tif (parentDom) {\n\t\t\t\t\t\tremoveChild(parentDom, item.dom);\n\t\t\t\t\t}\n\t\t\t\t\tunmount(item, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (parentDom && removePointer) {\n\t\t\tremoveChild(parentDom, pointer);\n\t\t}\n\t}\n\n\tfunction unmountVNode(node, parentDom, shallow) {\n\t\tvar instance = node.instance;\n\t\tvar instanceHooks = null;\n\t\tvar instanceChildren = null;\n\n\t\tif (!isNullOrUndefined(instance)) {\n\t\t\tinstanceHooks = instance.hooks;\n\t\t\tinstanceChildren = instance.children;\n\n\t\t\tif (instance.render !== undefined) {\n\t\t\t\tinstance.componentWillUnmount();\n\t\t\t\tinstance._unmounted = true;\n\t\t\t\tcomponentToDOMNodeMap.delete(instance);\n\t\t\t\t!shallow && unmount(instance._lastNode, null);\n\t\t\t}\n\t\t}\n\t\tvar hooks = node.hooks || instanceHooks;\n\n\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\tif (!isNullOrUndefined(hooks.willDetach)) {\n\t\t\t\thooks.willDetach(node.dom);\n\t\t\t}\n\t\t\tif (!isNullOrUndefined(hooks.componentWillUnmount)) {\n\t\t\t\thooks.componentWillUnmount(node.dom, hooks);\n\t\t\t}\n\t\t}\n\t\tvar children = (isNullOrUndefined(instance) ? node.children : null) || instanceChildren;\n\n\t\tif (!isNullOrUndefined(children)) {\n\t\t\tif (isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tunmount(children[i], null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunmount(children, null);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction VText(text) {\n\t\tthis.text = text;\n\t\tthis.dom = null;\n\t}\n\n\tfunction VPlaceholder() {\n\t\tthis.placeholder = true;\n\t\tthis.dom = null;\n\t}\n\n\tfunction VList(items) {\n\t\tthis.dom = null;\n\t\tthis.pointer = null;\n\t\tthis.items = items;\n\t}\n\n\tfunction createVText(text) {\n\t\treturn new VText(text);\n\t}\n\n\tfunction createVPlaceholder() {\n\t\treturn new VPlaceholder();\n\t}\n\n\tfunction createVList(items) {\n\t\treturn new VList(items);\n\t}\n\n\tfunction constructDefaults(string, object, value) {\n\t\t/* eslint no-return-assign: 0 */\n\t\tstring.split(',').forEach(function (i) { return object[i] = value; });\n\t}\n\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\tvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\n\tvar strictProps = {};\n\tvar booleanProps = {};\n\tvar namespaces = {};\n\tvar isUnitlessNumber = {};\n\n\tconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\n\tconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\n\tconstructDefaults('volume,value', strictProps, true);\n\tconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,selected,readonly,multiple,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\n\tconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\n\tfunction isVText(o) {\n\t\treturn o.text !== undefined;\n\t}\n\n\tfunction isVPlaceholder(o) {\n\t\treturn o.placeholder === true;\n\t}\n\n\tfunction isVList(o) {\n\t\treturn o.items !== undefined;\n\t}\n\n\tfunction isVNode(o) {\n\t\treturn o.tag !== undefined || o.bp !== undefined;\n\t}\n\n\tfunction insertOrAppend(parentDom, newNode, nextNode) {\n\t\tif (isNullOrUndefined(nextNode)) {\n\t\t\tparentDom.appendChild(newNode);\n\t\t} else {\n\t\t\tparentDom.insertBefore(newNode, nextNode);\n\t\t}\n\t}\n\n\tfunction replaceVListWithNode(parentDom, vList, dom) {\n\t\tvar pointer = vList.pointer;\n\n\t\tunmountVList(vList, parentDom, false);\n\t\treplaceNode(parentDom, dom, pointer);\n\t}\n\n\tfunction documentCreateElement(tag, isSVG) {\n\t\tvar dom;\n\n\t\tif (isSVG === true) {\n\t\t\tdom = document.createElementNS('http://www.w3.org/2000/svg', tag);\n\t\t} else {\n\t\t\tdom = document.createElement(tag);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction appendText(text, parentDom, singleChild) {\n\t\tif (parentDom === null) {\n\t\t\treturn document.createTextNode(text);\n\t\t} else {\n\t\t\tif (singleChild) {\n\t\t\t\tif (text !== '') {\n\t\t\t\t\tparentDom.textContent = text;\n\t\t\t\t\treturn parentDom.firstChild;\n\t\t\t\t} else {\n\t\t\t\t\tvar textNode = document.createTextNode('');\n\n\t\t\t\t\tparentDom.appendChild(textNode);\n\t\t\t\t\treturn textNode;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar textNode$1 = document.createTextNode(text);\n\n\t\t\t\tparentDom.appendChild(textNode$1);\n\t\t\t\treturn textNode$1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar lastInstance = null;\n\t\tvar instanceLastNode = lastNode._lastNode;\n\n\t\tif (!isNullOrUndefined(instanceLastNode)) {\n\t\t\tlastInstance = lastNode;\n\t\t\tlastNode = instanceLastNode;\n\t\t}\n\t\tunmount(lastNode, false);\n\t\tvar dom = mount(nextNode, null, lifecycle, context, instance, isSVG);\n\n\t\tnextNode.dom = dom;\n\t\treplaceNode(parentDom, dom, lastNode.dom);\n\t\tif (lastInstance !== null) {\n\t\t\tlastInstance._lastNode = nextNode;\n\t\t}\n\t}\n\n\tfunction replaceNode(parentDom, nextDom, lastDom) {\n\t\tparentDom.replaceChild(nextDom, lastDom);\n\t}\n\n\tfunction normalise(object) {\n\t\tif (isStringOrNumber(object)) {\n\t\t\treturn createVText(object);\n\t\t} else if (isInvalidNode(object)) {\n\t\t\treturn createVPlaceholder();\n\t\t} else if (isArray(object)) {\n\t\t\treturn createVList(object);\n\t\t}\n\t\treturn object;\n\t}\n\n\tfunction normaliseChild(children, i) {\n\t\tvar child = children[i];\n\n\t\treturn children[i] = normalise(child);\n\t}\n\n\tfunction remove(node, parentDom) {\n\t\tif (isVList(node)) {\n\t\t\treturn unmount(node, parentDom);\n\t\t}\n\t\tvar dom = node.dom;\n\t\tif (dom === parentDom) {\n\t\t\tdom.innerHTML = '';\n\t\t} else {\n\t\t\tremoveChild(parentDom, dom);\n\t\t\tif (recyclingEnabled) {\n\t\t\t\tpool(node);\n\t\t\t}\n\t\t}\n\t\tunmount(node, false);\n\t}\n\n\tfunction removeChild(parentDom, dom) {\n\t\tparentDom.removeChild(dom);\n\t}\n\n\tfunction removeEvents(events, lastEventKeys, dom) {\n\t\tvar eventKeys = lastEventKeys || Object.keys(events);\n\n\t\tfor (var i = 0; i < eventKeys.length; i++) {\n\t\t\tvar event = eventKeys[i];\n\n\t\t\tdom[event] = null;\n\t\t}\n\t}\n\n\t// TODO: for node we need to check if document is valid\n\tfunction getActiveNode() {\n\t\treturn document.activeElement;\n\t}\n\n\tfunction removeAllChildren(dom, children) {\n\t\tif (recyclingEnabled) {\n\t\t\tvar childrenLength = children.length;\n\n\t\t\tif (childrenLength > 5) {\n\t\t\t\tfor (var i = 0; i < childrenLength; i++) {\n\t\t\t\t\tvar child = children[i];\n\n\t\t\t\t\tif (!isInvalidNode(child)) {\n\t\t\t\t\t\tpool(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdom.textContent = '';\n\t}\n\n\tfunction resetActiveNode(activeNode) {\n\t\tif (activeNode !== null && activeNode !== document.body && document.activeElement !== activeNode) {\n\t\t\tactiveNode.focus(); // TODO: verify are we doing new focus event, if user has focus listener this might trigger it\n\t\t}\n\t}\n\n\tfunction isKeyed(lastChildren, nextChildren) {\n\t\tif (lastChildren.complex) {\n\t\t\treturn false;\n\t\t}\n\t\treturn nextChildren.length && !isNullOrUndefined(nextChildren[0]) && !isNullOrUndefined(nextChildren[0].key)\n\t\t\t&& lastChildren.length && !isNullOrUndefined(lastChildren[0]) && !isNullOrUndefined(lastChildren[0].key);\n\t}\n\n\tfunction selectOptionValueIfNeeded(vdom, values) {\n\t\tif (vdom.tag !== 'option') {\n\t\t\tfor (var i = 0, len = vdom.children.length; i < len; i++) {\n\t\t\t\tselectOptionValueIfNeeded(vdom.children[i], values);\n\t\t\t}\n\t\t\t// NOTE! Has to be a return here to catch optGroup elements\n\t\t\treturn;\n\t\t}\n\n\t\tvar value = vdom.attrs && vdom.attrs.value;\n\n\t\tif (values[value]) {\n\t\t\tvdom.attrs = vdom.attrs || {};\n\t\t\tvdom.attrs.selected = 'selected';\n\t\t\tvdom.dom.selected = true;\n\t\t} else {\n\t\t\tvdom.dom.selected = false;\n\t\t}\n\t}\n\n\tfunction selectValue(vdom) {\n\t\tvar value = vdom.attrs && vdom.attrs.value;\n\n\t\tvar values = {};\n\t\tif (isArray(value)) {\n\t\t\tfor (var i = 0, len = value.length; i < len; i++) {\n\t\t\t\tvalues[value[i]] = value[i];\n\t\t\t}\n\t\t} else {\n\t\t\tvalues[value] = value;\n\t\t}\n\t\tfor (var i$1 = 0, len$1 = vdom.children.length; i$1 < len$1; i$1++) {\n\t\t\tselectOptionValueIfNeeded(vdom.children[i$1], values);\n\t\t}\n\n\t\tif (vdom.attrs && vdom.attrs[value]) {\n\t\t\tdelete vdom.attrs.value; // TODO! Avoid deletion here. Set to null or undef. Not sure what you want to usev\n\t\t}\n\t}\n\n\tfunction handleAttachedHooks(hooks, lifecycle, dom) {\n\t\tif (!isNullOrUndefined(hooks.created)) {\n\t\t\thooks.created(dom);\n\t\t}\n\t\tif (!isNullOrUndefined(hooks.attached)) {\n\t\t\tlifecycle.addListener(function () {\n\t\t\t\thooks.attached(dom);\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction setValueProperty(nextNode) {\n\t\tvar value = nextNode.attrs.value;\n\t\tif (!isNullOrUndefined(value)) {\n\t\t\tnextNode.dom.value = value;\n\t\t}\n\t}\n\n\tfunction setFormElementProperties(nextTag, nextNode) {\n\t\tif (nextTag === 'input' && nextNode.attrs) {\n\t\t\tvar inputType = nextNode.attrs.type;\n\t\t\tif (inputType === 'text') {\n\t\t\t\tsetValueProperty(nextNode);\n\t\t\t} else if (inputType === 'checkbox' || inputType === 'radio') {\n\t\t\t\tvar checked = nextNode.attrs.checked;\n\t\t\t\tnextNode.dom.checked = !!checked;\n\t\t\t}\n\t\t} else if (nextTag === 'textarea') {\n\t\t\tsetValueProperty(nextNode);\n\t\t}\n\t}\n\n\tfunction mount(input, parentDom, lifecycle, context, instance, isSVG) {\n\t\tif (isVPlaceholder(input)) {\n\t\t\treturn mountVPlaceholder(input, parentDom);\n\t\t} else if (isVText(input)) {\n\t\t\treturn mountVText(input, parentDom);\n\t\t} else if (isVList(input)) {\n\t\t\treturn mountVList(input, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else if (isVNode(input)) {\n\t\t\treturn mountVNode$1(input, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else {\n\t\t\tvar normalisedInput = normalise(input);\n\n\t\t\tif (input !== normalisedInput) {\n\t\t\t\treturn mount(normalisedInput, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t} else {\n\t\t\t\tthrow new Error((\"Inferno Error: invalid object \\\"\" + (typeof input) + \"\\\" passed to mount()\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction mountVNode$1(vNode, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar bp = vNode.bp;\n\n\t\tif (isUndefined(bp)) {\n\t\t\treturn mountVNodeWithoutBlueprint(vNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else {\n\t\t\tif (recyclingEnabled) {\n\t\t\t\tvar dom = recycle(vNode, bp, lifecycle, context, instance);\n\n\t\t\t\tif (!isNull(dom)) {\n\t\t\t\t\tif (!isNull(parentDom)) {\n\t\t\t\t\t\tparentDom.appendChild(dom);\n\t\t\t\t\t}\n\t\t\t\t\treturn dom;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mountVNodeWithBlueprint(vNode, bp, parentDom, lifecycle, context, instance);\n\t\t}\n\t}\n\n\tfunction mountVList(vList, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar items = vList.items;\n\t\tvar pointer = document.createTextNode('');\n\t\tvar dom = document.createDocumentFragment();\n\n\t\tmountArrayChildren(items, dom, lifecycle, context, instance, isSVG);\n\t\tvList.pointer = pointer;\n\t\tvList.dom = dom;\n\t\tdom.appendChild(pointer);\n\t\tif (parentDom) {\n\t\t\tinsertOrAppend(parentDom, dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountVText(vText, parentDom) {\n\t\tvar dom = document.createTextNode(vText.text);\n\n\t\tvText.dom = dom;\n\t\tif (parentDom) {\n\t\t\tinsertOrAppend(parentDom, dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountVPlaceholder(vPlaceholder, parentDom) {\n\t\tvar dom = document.createTextNode('');\n\n\t\tvPlaceholder.dom = dom;\n\t\tif (parentDom) {\n\t\t\tinsertOrAppend(parentDom, dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction handleSelects(node) {\n\t\tif (node.tag === 'select') {\n\t\t\tselectValue(node);\n\t\t}\n\t}\n\n\tfunction mountBlueprintAttrs(node, bp, dom, instance) {\n\t\thandleSelects(node);\n\t\tvar attrs = node.attrs;\n\n\t\tif (isNull(bp.attrKeys)) {\n\t\t\tvar newKeys = Object.keys(attrs);\n\t\t\tbp.attrKeys = bp.attrKeys ? bp.attrKeys.concat(newKeys) : newKeys;\n\t\t}\n\t\tvar attrKeys = bp.attrKeys;\n\n\t\tmountAttributes(node, attrs, attrKeys, dom, instance);\n\t}\n\n\tfunction mountBlueprintEvents(node, bp, dom) {\n\t\tvar events = node.events;\n\n\t\tif (isNull(bp.eventKeys)) {\n\t\t\tbp.eventKeys = Object.keys(events);\n\t\t}\n\t\tvar eventKeys = bp.eventKeys;\n\n\t\tmountEvents(events, eventKeys, dom);\n\t}\n\n\tfunction mountVNodeWithBlueprint(node, bp, parentDom, lifecycle, context, instance) {\n\t\tvar tag = node.tag;\n\n\t\tif (isTrue(bp.isComponent)) {\n\t\t\treturn mountComponent(node, tag, node.attrs || {}, node.hooks, node.children, instance, parentDom, lifecycle, context);\n\t\t}\n\t\tvar dom = documentCreateElement(bp.tag, bp.isSVG);\n\n\t\tnode.dom = dom;\n\t\tif (isTrue(bp.hasHooks)) {\n\t\t\thandleAttachedHooks(node.hooks, lifecycle, dom);\n\t\t}\n\t\tif (isTrue(bp.lazy)) {\n\t\t\thandleLazyAttached(node, lifecycle, dom);\n\t\t}\n\t\tvar children = node.children;\n\t\t// bp.childrenType:\n\t\t// 0: no children\n\t\t// 1: text node\n\t\t// 2: single child\n\t\t// 3: multiple children\n\t\t// 4: multiple children (keyed)\n\t\t// 5: variable children (defaults to no optimisation)\n\n\t\tswitch (bp.childrenType) {\n\t\t\tcase 1:\n\t\t\t\tappendText(children, dom, true);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tmount(node.children, dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tmountArrayChildren(children, dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\tmount(children[i], dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tmountChildren(node, children, dom, lifecycle, context, instance, bp.isSVG);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (isTrue(bp.hasAttrs)) {\n\t\t\tmountBlueprintAttrs(node, bp, dom, instance);\n\t\t}\n\t\tif (isTrue(bp.hasClassName)) {\n\t\t\tdom.className = node.className;\n\t\t}\n\t\tif (isTrue(bp.hasStyle)) {\n\t\t\tpatchStyle(null, node.style, dom);\n\t\t}\n\t\tif (isTrue(bp.hasEvents)) {\n\t\t\tmountBlueprintEvents(node, bp, dom);\n\t\t}\n\t\tif (!isNull(parentDom)) {\n\t\t\tparentDom.appendChild(dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountVNodeWithoutBlueprint(node, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar tag = node.tag;\n\n\t\tif (isFunction(tag)) {\n\t\t\treturn mountComponent(node, tag, node.attrs || {}, node.hooks, node.children, instance, parentDom, lifecycle, context);\n\t\t}\n\t\tif (!isString(tag) || tag === '') {\n\t\t\tthrow Error('Inferno Error: Expected function or string for element tag type');\n\t\t}\n\t\tif (tag === 'svg') {\n\t\t\tisSVG = true;\n\t\t}\n\t\tvar dom = documentCreateElement(tag, isSVG);\n\t\tvar children = node.children;\n\t\tvar attrs = node.attrs;\n\t\tvar events = node.events;\n\t\tvar hooks = node.hooks;\n\t\tvar className = node.className;\n\t\tvar style = node.style;\n\n\t\tnode.dom = dom;\n\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\thandleAttachedHooks(hooks, lifecycle, dom);\n\t\t}\n\t\tif (!isInvalidNode(children)) {\n\t\t\tmountChildren(node, children, dom, lifecycle, context, instance, isSVG);\n\t\t}\n\t\tif (!isNullOrUndefined(attrs)) {\n\t\t\thandleSelects(node);\n\t\t\tmountAttributes(node, attrs, Object.keys(attrs), dom, instance);\n\t\t}\n\t\tif (!isNullOrUndefined(className)) {\n\t\t\tdom.className = className;\n\t\t}\n\t\tif (!isNullOrUndefined(style)) {\n\t\t\tpatchStyle(null, style, dom);\n\t\t}\n\t\tif (!isNullOrUndefined(events)) {\n\t\t\tmountEvents(events, Object.keys(events), dom);\n\t\t}\n\t\tif (!isNull(parentDom)) {\n\t\t\tparentDom.appendChild(dom);\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountArrayChildren(children, parentDom, lifecycle, context, instance, isSVG) {\n\t\tchildren.complex = false;\n\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\tvar child = normaliseChild(children, i);\n\n\t\t\tif (isVText(child)) {\n\t\t\t\tmountVText(child, parentDom);\n\t\t\t\tchildren.complex = true;\n\t\t\t} else if (isVPlaceholder(child)) {\n\t\t\t\tmountVPlaceholder(child, parentDom);\n\t\t\t\tchildren.complex = true;\n\t\t\t} else if (isVList(child)) {\n\t\t\t\tmountVList(child, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\tchildren.complex = true;\n\t\t\t} else {\n\t\t\t\tmount(child, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction mountChildren(node, children, parentDom, lifecycle, context, instance, isSVG) {\n\t\tif (isArray(children)) {\n\t\t\tmountArrayChildren(children, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else if (isStringOrNumber(children)) {\n\t\t\tappendText(children, parentDom, true);\n\t\t} else if (!isInvalidNode(children)) {\n\t\t\tmount(children, parentDom, lifecycle, context, instance, isSVG);\n\t\t}\n\t}\n\n\tfunction mountRef(instance, value, refValue) {\n\t\tif (!isInvalidNode(instance) && isString(value)) {\n\t\t\tinstance.refs[value] = refValue;\n\t\t}\n\t}\n\n\tfunction mountEvents(events, eventKeys, dom) {\n\t\tfor (var i = 0; i < eventKeys.length; i++) {\n\t\t\tvar event = eventKeys[i];\n\n\t\t\tdom[event] = events[event];\n\t\t}\n\t}\n\n\tfunction mountComponent(parentNode, Component, props, hooks, children, lastInstance, parentDom, lifecycle, context) {\n\t\tprops = addChildrenToProps(children, props);\n\n\t\tvar dom;\n\t\tif (isStatefulComponent(Component)) {\n\t\t\tvar instance = new Component(props, context);\n\n\t\t\tinstance._patch = patch;\n\t\t\tinstance._componentToDOMNodeMap = componentToDOMNodeMap;\n\t\t\tif (!isNullOrUndefined(lastInstance) && props.ref) {\n\t\t\t\tmountRef(lastInstance, props.ref, instance);\n\t\t\t}\n\t\t\tvar childContext = instance.getChildContext();\n\n\t\t\tif (!isNullOrUndefined(childContext)) {\n\t\t\t\tcontext = Object.assign({}, context, childContext);\n\t\t\t}\n\t\t\tinstance.context = context;\n\t\t\tinstance._unmounted = false;\n\t\t\tinstance._parentNode = parentNode;\n\t\t\tif (lastInstance) {\n\t\t\t\tinstance._parentComponent = lastInstance;\n\t\t\t}\n\t\t\tinstance._pendingSetState = true;\n\t\t\tinstance.componentWillMount();\n\t\t\tvar node = instance.render();\n\n\t\t\tif (isInvalidNode(node)) {\n\t\t\t\tnode = createVPlaceholder();\n\t\t\t}\n\t\t\tinstance._pendingSetState = false;\n\t\t\tdom = mount(node, null, lifecycle, context, instance, false);\n\t\t\tinstance._lastNode = node;\n\t\t\tinstance.componentDidMount();\n\t\t\tif (parentDom !== null && !isInvalidNode(dom)) {\n\t\t\t\tparentDom.appendChild(dom);\n\t\t\t}\n\t\t\tcomponentToDOMNodeMap.set(instance, dom);\n\t\t\tparentNode.dom = dom;\n\t\t\tparentNode.instance = instance;\n\t\t} else {\n\t\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\t\tif (!isNullOrUndefined(hooks.componentWillMount)) {\n\t\t\t\t\thooks.componentWillMount(null, props);\n\t\t\t\t}\n\t\t\t\tif (!isNullOrUndefined(hooks.componentDidMount)) {\n\t\t\t\t\tlifecycle.addListener(function () {\n\t\t\t\t\t\thooks.componentDidMount(dom, props);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* eslint new-cap: 0 */\n\t\t\tvar node$1 = Component(props, context);\n\n\t\t\tif (isInvalidNode(node$1)) {\n\t\t\t\tnode$1 = createVPlaceholder();\n\t\t\t}\n\t\t\tdom = mount(node$1, null, lifecycle, context, null, false);\n\n\t\t\tparentNode.instance = node$1;\n\n\t\t\tif (parentDom !== null && !isInvalidNode(dom)) {\n\t\t\t\tparentDom.appendChild(dom);\n\t\t\t}\n\t\t\tparentNode.dom = dom;\n\t\t}\n\t\treturn dom;\n\t}\n\n\tfunction mountAttributes(node, attrs, attrKeys, dom, instance) {\n\t\tfor (var i = 0; i < attrKeys.length; i++) {\n\t\t\tvar attr = attrKeys[i];\n\n\t\t\tif (attr === 'ref') {\n\t\t\t\tmountRef(getRefInstance$1(node, instance), attrs[attr], dom);\n\t\t\t} else {\n\t\t\t\tpatchAttribute(attr, null, attrs[attr], dom);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patch(lastInput, nextInput, parentDom, lifecycle, context, instance, isSVG) {\n\t\tif (lastInput !== nextInput) {\n\t\t\tif (isInvalidNode(lastInput)) {\n\t\t\t\tmount(nextInput, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t} else if (isInvalidNode(nextInput)) {\n\t\t\t\tremove(lastInput, parentDom);\n\t\t\t} else if (isStringOrNumber(lastInput)) {\n\t\t\t\tif (isStringOrNumber(nextInput)) {\n\t\t\t\t\tparentDom.firstChild.nodeValue = nextInput;\n\t\t\t\t} else {\n\t\t\t\t\tvar dom = mount(nextInput, null, lifecycle, context, instance, isSVG);\n\n\t\t\t\t\tnextInput.dom = dom;\n\t\t\t\t\treplaceNode(parentDom, dom, parentDom.firstChild);\n\t\t\t\t}\n\t\t\t} else if (isStringOrNumber(nextInput)) {\n\t\t\t\treplaceNode(parentDom, document.createTextNode(nextInput), lastInput.dom);\n\t\t\t} else {\n\t\t\t\tif (isVList(nextInput)) {\n\t\t\t\t\tif (isVList(lastInput)) {\n\t\t\t\t\t\tpatchVList(lastInput, nextInput, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplaceNode(parentDom, mountVList(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t}\n\t\t\t\t} else if (isVList(lastInput)) {\n\t\t\t\t\treplaceVListWithNode(parentDom, lastInput, mount(nextInput, null, lifecycle, context, instance, isSVG));\n\t\t\t\t} else if (isVPlaceholder(nextInput)) {\n\t\t\t\t\tif (isVPlaceholder(lastInput)) {\n\t\t\t\t\t\tpatchVFragment(lastInput, nextInput);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplaceNode(parentDom, mountVPlaceholder(nextInput, null), lastInput.dom);\n\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t}\n\t\t\t\t} else if (isVPlaceholder(lastInput)) {\n\t\t\t\t\treplaceNode(parentDom, mount(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t} else if (isVText(nextInput)) {\n\t\t\t\t\tif (isVText(lastInput)) {\n\t\t\t\t\t\tpatchVText(lastInput, nextInput);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplaceNode(parentDom, mountVText(nextInput, null), lastInput.dom);\n\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t}\n\t\t\t\t} else if (isVText(lastInput)) {\n\t\t\t\t\treplaceNode(parentDom, mount(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t} else if (isVNode(nextInput)) {\n\t\t\t\t\tif (isVNode(lastInput)) {\n\t\t\t\t\t\tpatchVNode(lastInput, nextInput, parentDom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treplaceNode(parentDom, mountVNode(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t\t}\n\t\t\t\t} else if (isVNode(lastInput)) {\n\t\t\t\t\treplaceNode(parentDom, mount(nextInput, null, lifecycle, context, instance, isSVG), lastInput.dom);\n\t\t\t\t\tunmount(lastInput, null);\n\t\t\t\t} else {\n\t\t\t\t\treturn patch(lastInput, normalise(nextInput), parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nextInput;\n\t}\n\n\tfunction patchTextNode(dom, lastChildren, nextChildren) {\n\t\tif (isStringOrNumber(lastChildren)) {\n\t\t\tdom.firstChild.nodeValue = nextChildren;\n\t\t} else {\n\t\t\tdom.textContent = nextChildren;\n\t\t}\n\t}\n\n\tfunction patchRef(instance, lastValue, nextValue, dom) {\n\t\tif (instance) {\n\t\t\tif (isString(lastValue)) {\n\t\t\t\tdelete instance.refs[lastValue];\n\t\t\t}\n\t\t\tif (isString(nextValue)) {\n\t\t\t\tinstance.refs[nextValue] = dom;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchChildren(lastNode, nextNode, dom, lifecycle, context, instance, isSVG) {\n\t\tvar nextChildren = nextNode.children;\n\t\tvar lastChildren = lastNode.children;\n\n\t\tif (lastChildren === nextChildren) {\n\t\t\treturn;\n\t\t}\n\t\tif (isInvalidNode(lastChildren)) {\n\t\t\tif (isStringOrNumber(nextChildren)) {\n\t\t\t\tpatchTextNode(dom, lastChildren, nextChildren);\n\t\t\t} else if (!isInvalidNode(nextChildren)) {\n\t\t\t\tif (isArray(nextChildren)) {\n\t\t\t\t\tmountArrayChildren(nextChildren, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t} else {\n\t\t\t\t\tmount(nextChildren, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (isInvalidNode(nextChildren)) {\n\t\t\t\tremoveAllChildren(dom, lastChildren);\n\t\t\t} else {\n\t\t\t\tif (isArray(lastChildren)) {\n\t\t\t\t\tif (isArray(nextChildren)) {\n\t\t\t\t\t\tnextChildren.complex = lastChildren.complex;\n\t\t\t\t\t\tif (isKeyed(lastChildren, nextChildren)) {\n\t\t\t\t\t\t\tpatchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpatchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpatchNonKeyedChildren(lastChildren, [nextChildren], dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (isArray(nextChildren)) {\n\t\t\t\t\t\tvar lastChild = lastChildren;\n\n\t\t\t\t\t\tif (isStringOrNumber(lastChildren)) {\n\t\t\t\t\t\t\tlastChild = createVText(lastChild);\n\t\t\t\t\t\t\tlastChild.dom = dom.firstChild;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpatchNonKeyedChildren([lastChild], nextChildren, dom, lifecycle, context, instance, isSVG, null);\n\t\t\t\t\t} else if (isStringOrNumber(nextChildren)) {\n\t\t\t\t\t\tpatchTextNode(dom, lastChildren, nextChildren);\n\t\t\t\t\t} else if (isStringOrNumber(lastChildren)) {\n\t\t\t\t\t\tpatch(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpatchVNode(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchVNode(lastVNode, nextVNode, parentDom, lifecycle, context, instance, isSVG, skipLazyCheck) {\n\t\tvar lastBp = lastVNode.bp;\n\t\tvar nextBp = nextVNode.bp;\n\n\t\tif (lastBp === undefined || nextBp === undefined) {\n\t\t\tpatchVNodeWithoutBlueprint(lastVNode, nextVNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t} else {\n\t\t\tpatchVNodeWithBlueprint(lastVNode, nextVNode, lastBp, nextBp, parentDom, lifecycle, context, instance, skipLazyCheck);\n\t\t}\n\t}\n\n\tfunction patchVNodeWithBlueprint(lastVNode, nextVNode, lastBp, nextBp, parentDom, lifecycle, context, instance, skipLazyCheck) {\n\t\tvar nextHooks;\n\n\t\tif (nextBp.hasHooks === true) {\n\t\t\tnextHooks = nextVNode.hooks;\n\t\t\tif (nextHooks && !isNullOrUndefined(nextHooks.willUpdate)) {\n\t\t\t\tnextHooks.willUpdate(lastVNode.dom);\n\t\t\t}\n\t\t}\n\t\tvar nextTag = nextVNode.tag || nextBp.tag;\n\t\tvar lastTag = lastVNode.tag || lastBp.tag;\n\n\t\tif (lastTag !== nextTag) {\n\t\t\tif (lastBp.isComponent === true) {\n\t\t\t\tvar lastNodeInstance = lastVNode.instance;\n\n\t\t\t\tif (nextBp.isComponent === true) {\n\t\t\t\t\treplaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, instance, false);\n\t\t\t\t} else if (isStatefulComponent(lastTag)) {\n\t\t\t\t\tunmountVNode(lastVNode, null, true);\n\t\t\t\t\tvar lastNode = lastNodeInstance._lastNode;\n\t\t\t\t\tpatchVNodeWithBlueprint(lastNode, nextVNode, lastNode.bp, nextBp, parentDom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t} else {\n\t\t\t\t\tunmountVNode(lastVNode, null, true);\n\t\t\t\t\tpatchVNodeWithBlueprint(lastNodeInstance, nextVNode, lastNodeInstance.bp, nextBp, parentDom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treplaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t}\n\t\t} else if (isNullOrUndefined(lastTag)) {\n\t\t\tnextVNode.dom = lastVNode.dom;\n\t\t} else {\n\t\t\tif (lastBp.isComponent === true) {\n\t\t\t\tif (nextBp.isComponent === true) {\n\t\t\t\t\tvar instance$1 = lastVNode.instance;\n\n\t\t\t\t\tif (!isNullOrUndefined(instance$1) && instance$1._unmounted) {\n\t\t\t\t\t\tvar newDom = mountComponent(nextVNode, lastTag, nextVNode.attrs || {}, nextVNode.hooks, nextVNode.children, instance$1, parentDom, lifecycle, context);\n\t\t\t\t\t\tif (parentDom !== null) {\n\t\t\t\t\t\t\treplaceNode(parentDom, newDom, lastVNode.dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextVNode.instance = instance$1;\n\t\t\t\t\t\tnextVNode.dom = lastVNode.dom;\n\t\t\t\t\t\tpatchComponent(true, nextVNode, nextVNode.tag, lastBp, nextBp, instance$1, lastVNode.attrs || {}, nextVNode.attrs || {}, nextVNode.hooks, lastVNode.children, nextVNode.children, parentDom, lifecycle, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar dom = lastVNode.dom;\n\t\t\t\tvar lastChildrenType = lastBp.childrenType;\n\t\t\t\tvar nextChildrenType = nextBp.childrenType;\n\t\t\t\tnextVNode.dom = dom;\n\n\t\t\t\tif (nextBp.lazy === true && skipLazyCheck === false) {\n\t\t\t\t\tvar clipData = lastVNode.clipData;\n\n\t\t\t\t\tif (lifecycle.scrollY === null) {\n\t\t\t\t\t\tlifecycle.refresh();\n\t\t\t\t\t}\n\n\t\t\t\t\tnextVNode.clipData = clipData;\n\t\t\t\t\tif (clipData.pending === true || clipData.top - lifecycle.scrollY > lifecycle.screenHeight) {\n\t\t\t\t\t\tif (setClipNode(clipData, dom, lastVNode, nextVNode, parentDom, lifecycle, context, instance, lastBp.isSVG)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (clipData.bottom < lifecycle.scrollY) {\n\t\t\t\t\t\tif (setClipNode(clipData, dom, lastVNode, nextVNode, parentDom, lifecycle, context, instance, lastBp.isSVG)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lastChildrenType > 0 || nextChildrenType > 0) {\n\t\t\t\t\tif (nextChildrenType === 5 || lastChildrenType === 5) {\n\t\t\t\t\t\tpatchChildren(lastVNode, nextVNode, dom, lifecycle, context, instance);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar lastChildren = lastVNode.children;\n\t\t\t\t\t\tvar nextChildren = nextVNode.children;\n\n\t\t\t\t\t\tif (lastChildrenType === 0 || isInvalidNode(lastChildren)) {\n\t\t\t\t\t\t\tif (nextChildrenType > 2) {\n\t\t\t\t\t\t\t\tmountArrayChildren(nextChildren, dom, lifecycle, context, instance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmount(nextChildren, dom, lifecycle, context, instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (nextChildrenType === 0 || isInvalidNode(nextChildren)) {\n\t\t\t\t\t\t\tif (lastChildrenType > 2) {\n\t\t\t\t\t\t\t\tremoveAllChildren(dom, lastChildren);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tremove(lastChildren, dom);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (lastChildren !== nextChildren) {\n\t\t\t\t\t\t\t\tif (lastChildrenType === 4 && nextChildrenType === 4) {\n\t\t\t\t\t\t\t\t\tpatchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, nextBp.isSVG, null);\n\t\t\t\t\t\t\t\t} else if (lastChildrenType === 2 && nextChildrenType === 2) {\n\t\t\t\t\t\t\t\t\tpatch(lastChildren, nextChildren, dom, lifecycle, context, instance, true, nextBp.isSVG);\n\t\t\t\t\t\t\t\t} else if (lastChildrenType === 1 && nextChildrenType === 1) {\n\t\t\t\t\t\t\t\t\tpatchTextNode(dom, lastChildren, nextChildren);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpatchChildren(lastVNode, nextVNode, dom, lifecycle, context, instance, nextBp.isSVG);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lastBp.hasAttrs === true || nextBp.hasAttrs === true) {\n\t\t\t\t\tpatchAttributes(lastVNode, nextVNode, lastBp.attrKeys, nextBp.attrKeys, dom, instance);\n\t\t\t\t}\n\t\t\t\tif (lastBp.hasEvents === true || nextBp.hasEvents === true) {\n\t\t\t\t\tpatchEvents(lastVNode.events, nextVNode.events, lastBp.eventKeys, nextBp.eventKeys, dom);\n\t\t\t\t}\n\t\t\t\tif (lastBp.hasClassName === true || nextBp.hasClassName === true) {\n\t\t\t\t\tvar nextClassName = nextVNode.className;\n\n\t\t\t\t\tif (lastVNode.className !== nextClassName) {\n\t\t\t\t\t\tif (isNullOrUndefined(nextClassName)) {\n\t\t\t\t\t\t\tdom.removeAttribute('class');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdom.className = nextClassName;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lastBp.hasStyle === true || nextBp.hasStyle === true) {\n\t\t\t\t\tvar nextStyle = nextVNode.style;\n\t\t\t\t\tvar lastStyle = lastVNode.style;\n\n\t\t\t\t\tif (lastStyle !== nextStyle) {\n\t\t\t\t\t\tpatchStyle(lastStyle, nextStyle, dom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nextBp.hasHooks === true && !isNullOrUndefined(nextHooks.didUpdate)) {\n\t\t\t\t\tnextHooks.didUpdate(dom);\n\t\t\t\t}\n\t\t\t\tsetFormElementProperties(nextTag, nextVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchVNodeWithoutBlueprint(lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar nextHooks = nextNode.hooks;\n\t\tvar nextHooksDefined = !isNullOrUndefined(nextHooks);\n\n\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.willUpdate)) {\n\t\t\tnextHooks.willUpdate(lastNode.dom);\n\t\t}\n\t\tvar nextTag = nextNode.tag || ((isNullOrUndefined(nextNode.bp)) ? null : nextNode.bp.tag);\n\t\tvar lastTag = lastNode.tag || ((isNullOrUndefined(lastNode.bp)) ? null : lastNode.bp.tag);\n\n\t\tif (nextTag === 'svg') {\n\t\t\tisSVG = true;\n\t\t}\n\t\tif (lastTag !== nextTag) {\n\t\t\tvar lastNodeInstance = lastNode.instance;\n\n\t\t\tif (isFunction(lastTag)) {\n\t\t\t\tif (isFunction(nextTag)) {\n\t\t\t\t\treplaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t} else if (isStatefulComponent(lastTag)) {\n\t\t\t\t\tunmountVNode(lastNode, null, true);\n\t\t\t\t\tpatchVNodeWithoutBlueprint(lastNodeInstance._lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t} else {\n\t\t\t\t\tunmountVNode(lastNode, null, true);\n\t\t\t\t\tpatchVNodeWithoutBlueprint(lastNodeInstance, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treplaceWithNewNode(lastNodeInstance || lastNode, nextNode, parentDom, lifecycle, context, instance, isSVG);\n\t\t\t}\n\t\t} else if (isNullOrUndefined(lastTag)) {\n\t\t\tnextNode.dom = lastNode.dom;\n\t\t} else {\n\t\t\tif (isFunction(lastTag)) {\n\t\t\t\tif (isFunction(nextTag)) {\n\t\t\t\t\tvar instance$1 = lastNode._instance;\n\n\t\t\t\t\tif (!isNullOrUndefined(instance$1) && instance$1._unmounted) {\n\t\t\t\t\t\tvar newDom = mountComponent(nextNode, lastTag, nextNode.attrs || {}, nextNode.hooks, nextNode.children, instance$1, parentDom, lifecycle, context);\n\t\t\t\t\t\tif (parentDom !== null) {\n\t\t\t\t\t\t\treplaceNode(parentDom, newDom, lastNode.dom);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextNode.instance = lastNode.instance;\n\t\t\t\t\t\tnextNode.dom = lastNode.dom;\n\t\t\t\t\t\tpatchComponent(false, nextNode, nextNode.tag, null, null, nextNode.instance, lastNode.attrs || {}, nextNode.attrs || {}, nextNode.hooks, lastNode.children, nextNode.children, parentDom, lifecycle, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar dom = lastNode.dom;\n\t\t\t\tvar nextClassName = nextNode.className;\n\t\t\t\tvar nextStyle = nextNode.style;\n\n\t\t\t\tnextNode.dom = dom;\n\n\t\t\t\tpatchChildren(lastNode, nextNode, dom, lifecycle, context, instance, isSVG);\n\t\t\t\tpatchAttributes(lastNode, nextNode, null, null, dom, instance);\n\t\t\t\tpatchEvents(lastNode.events, nextNode.events, null, null, dom);\n\n\t\t\t\tif (lastNode.className !== nextClassName) {\n\t\t\t\t\tif (isNullOrUndefined(nextClassName)) {\n\t\t\t\t\t\tdom.removeAttribute('class');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.className = nextClassName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lastNode.style !== nextStyle) {\n\t\t\t\t\tpatchStyle(lastNode.style, nextStyle, dom);\n\t\t\t\t}\n\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.didUpdate)) {\n\t\t\t\t\tnextHooks.didUpdate(dom);\n\t\t\t\t}\n\t\t\t\tsetFormElementProperties(nextTag, nextNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchAttributes(lastNode, nextNode, lastAttrKeys, nextAttrKeys, dom, instance) {\n\t\tif (lastNode.tag === 'select') {\n\t\t\tselectValue(nextNode);\n\t\t}\n\t\tvar nextAttrs = nextNode.attrs;\n\t\tvar lastAttrs = lastNode.attrs;\n\t\tvar nextAttrsIsUndef = isNullOrUndefined(nextAttrs);\n\t\tvar lastAttrsIsNotUndef = !isNullOrUndefined(lastAttrs);\n\n\t\tif (!nextAttrsIsUndef) {\n\t\t\tvar nextAttrsKeys = nextAttrKeys || Object.keys(nextAttrs);\n\t\t\tvar attrKeysLength = nextAttrsKeys.length;\n\n\t\t\tfor (var i = 0; i < attrKeysLength; i++) {\n\t\t\t\tvar attr = nextAttrsKeys[i];\n\t\t\t\tvar lastAttrVal = lastAttrsIsNotUndef && lastAttrs[attr];\n\t\t\t\tvar nextAttrVal = nextAttrs[attr];\n\n\t\t\t\tif (lastAttrVal !== nextAttrVal) {\n\t\t\t\t\tif (attr === 'ref') {\n\t\t\t\t\t\tpatchRef(instance, lastAttrVal, nextAttrVal, dom);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpatchAttribute(attr, lastAttrVal, nextAttrVal, dom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (lastAttrsIsNotUndef) {\n\t\t\tvar lastAttrsKeys = lastAttrKeys || Object.keys(lastAttrs);\n\t\t\tvar attrKeysLength$1 = lastAttrsKeys.length;\n\n\t\t\tfor (var i$1 = 0; i$1 < attrKeysLength$1; i$1++) {\n\t\t\t\tvar attr$1 = lastAttrsKeys[i$1];\n\n\t\t\t\tif (nextAttrsIsUndef || isNullOrUndefined(nextAttrs[attr$1])) {\n\t\t\t\t\tif (attr$1 === 'ref') {\n\t\t\t\t\t\tpatchRef(getRefInstance(node, instance), lastAttrs[attr$1], null, dom);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.removeAttribute(attr$1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n\t\tif (isString(nextAttrValue)) {\n\t\t\tdom.style.cssText = nextAttrValue;\n\t\t} else if (isNullOrUndefined(lastAttrValue)) {\n\t\t\tif (!isNullOrUndefined(nextAttrValue)) {\n\t\t\t\tvar styleKeys = Object.keys(nextAttrValue);\n\n\t\t\t\tfor (var i = 0; i < styleKeys.length; i++) {\n\t\t\t\t\tvar style = styleKeys[i];\n\t\t\t\t\tvar value = nextAttrValue[style];\n\n\t\t\t\t\tif (isNumber(value) && !isUnitlessNumber[style]) {\n\t\t\t\t\t\tdom.style[style] = value + 'px';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.style[style] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isNullOrUndefined(nextAttrValue)) {\n\t\t\tdom.removeAttribute('style');\n\t\t} else {\n\t\t\tvar styleKeys$1 = Object.keys(nextAttrValue);\n\n\t\t\tfor (var i$1 = 0; i$1 < styleKeys$1.length; i$1++) {\n\t\t\t\tvar style$1 = styleKeys$1[i$1];\n\t\t\t\tvar value$1 = nextAttrValue[style$1];\n\n\t\t\t\tif (isNumber(value$1) && !isUnitlessNumber[style$1]) {\n\t\t\t\t\tdom.style[style$1] = value$1 + 'px';\n\t\t\t\t} else {\n\t\t\t\t\tdom.style[style$1] = value$1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar lastStyleKeys = Object.keys(lastAttrValue);\n\n\t\t\tfor (var i$2 = 0; i$2 < lastStyleKeys.length; i$2++) {\n\t\t\t\tvar style$2 = lastStyleKeys[i$2];\n\t\t\t\tif (isNullOrUndefined(nextAttrValue[style$2])) {\n\t\t\t\t\tdom.style[style$2] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchEvents(lastEvents, nextEvents, _lastEventKeys, _nextEventKeys, dom) {\n\t\tvar nextEventsDefined = !isNullOrUndefined(nextEvents);\n\t\tvar lastEventsDefined = !isNullOrUndefined(lastEvents);\n\t\tvar lastEventKeys;\n\n\t\tif (lastEventsDefined) {\n\t\t\tlastEventKeys = _lastEventKeys || Object.keys(lastEvents);\n\t\t}\n\t\tif (nextEventsDefined) {\n\t\t\tvar nextEventKeys = _nextEventKeys || Object.keys(nextEvents);\n\n\t\t\tif (lastEventsDefined) {\n\t\t\t\tfor (var i = 0; i < nextEventKeys.length; i++) {\n\t\t\t\t\tvar event = nextEventKeys[i];\n\t\t\t\t\tvar lastEvent = lastEvents[event];\n\t\t\t\t\tvar nextEvent = nextEvents[event];\n\n\t\t\t\t\tif (lastEvent !== nextEvent) {\n\t\t\t\t\t\tdom[event] = nextEvent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var i$1 = 0; i$1 < lastEventKeys.length; i$1++) {\n\t\t\t\t\tvar event$1 = lastEventKeys[i$1];\n\n\t\t\t\t\tif (isNullOrUndefined(nextEvents[event$1])) {\n\t\t\t\t\t\tdom[event$1] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmountEvents(nextEvents, nextEventKeys, dom);\n\t\t\t}\n\t\t} else if (lastEventsDefined) {\n\t\t\tremoveEvents(lastEvents, lastEventKeys, dom);\n\t\t}\n\t}\n\n\tfunction patchAttribute(attrName, lastAttrValue, nextAttrValue, dom) {\n\t\tif (attrName === 'dangerouslySetInnerHTML') {\n\t\t\tvar lastHtml = lastAttrValue && lastAttrValue.__html;\n\t\t\tvar nextHtml = nextAttrValue && nextAttrValue.__html;\n\n\t\t\tif (isNullOrUndefined(nextHtml)) {\n\t\t\t\tthrow new Error('Inferno Error: dangerouslySetInnerHTML requires an object with a __html propety containing the innerHTML content');\n\t\t\t}\n\t\t\tif (lastHtml !== nextHtml) {\n\t\t\t\tdom.innerHTML = nextHtml;\n\t\t\t}\n\t\t} else if (attrName === 'eventData') {\n\t\t\tdom.eventData = nextAttrValue;\n\t\t} else if (strictProps[attrName]) {\n\t\t\tdom[attrName] = nextAttrValue === null ? '' : nextAttrValue;\n\t\t} else {\n\t\t\tif (booleanProps[attrName]) {\n\t\t\t\tdom[attrName] = nextAttrValue ? true : false;\n\t\t\t} else {\n\t\t\t\tvar ns = namespaces[attrName];\n\n\t\t\t\tif (nextAttrValue === false || isNullOrUndefined(nextAttrValue)) {\n\t\t\t\t\tif (ns !== undefined) {\n\t\t\t\t\t\tdom.removeAttributeNS(ns, attrName);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.removeAttribute(attrName);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ns !== undefined) {\n\t\t\t\t\t\tdom.setAttributeNS(ns, attrName, nextAttrValue === true ? attrName : nextAttrValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.setAttribute(attrName, nextAttrValue === true ? attrName : nextAttrValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchComponent(hasBlueprint, lastNode, Component, lastBp, nextBp, instance, lastProps, nextProps, nextHooks, lastChildren, nextChildren, parentDom, lifecycle, context) {\n\t\tnextProps = addChildrenToProps(nextChildren, nextProps);\n\n\t\tif (isStatefulComponent(Component)) {\n\t\t\tvar prevProps = instance.props;\n\t\t\tvar prevState = instance.state;\n\t\t\tvar nextState = instance.state;\n\n\t\t\tvar childContext = instance.getChildContext();\n\t\t\tif (!isNullOrUndefined(childContext)) {\n\t\t\t\tcontext = Object.assign({}, context, childContext);\n\t\t\t}\n\t\t\tinstance.context = context;\n\t\t\tvar nextNode = instance._updateComponent(prevState, nextState, prevProps, nextProps);\n\n\t\t\tif (nextNode === NO_RENDER) {\n\t\t\t\tnextNode = instance._lastNode;\n\t\t\t} else if (isNullOrUndefined(nextNode)) {\n\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t}\n\t\t\tpatch(instance._lastNode, nextNode, parentDom, lifecycle, context, instance, null, false);\n\t\t\tlastNode.dom = nextNode.dom;\n\t\t\tinstance._lastNode = nextNode;\n\t\t\tinstance.componentDidUpdate(prevProps, prevState);\n\t\t\tcomponentToDOMNodeMap.set(instance, nextNode.dom);\n\t\t} else {\n\t\t\tvar shouldUpdate = true;\n\t\t\tvar nextHooksDefined = (hasBlueprint && nextBp.hasHooks === true) || !isNullOrUndefined(nextHooks);\n\n\t\t\tlastProps = addChildrenToProps(lastChildren, lastProps);\n\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.componentShouldUpdate)) {\n\t\t\t\tshouldUpdate = nextHooks.componentShouldUpdate(lastNode.dom, lastProps, nextProps);\n\t\t\t}\n\t\t\tif (shouldUpdate !== false) {\n\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.componentWillUpdate)) {\n\t\t\t\t\tnextHooks.componentWillUpdate(lastNode.dom, lastProps, nextProps);\n\t\t\t\t}\n\t\t\t\tvar nextNode$1 = Component(nextProps, context);\n\n\t\t\t\tif (isInvalidNode(nextNode$1)) {\n\t\t\t\t\tnextNode$1 = createVPlaceholder();\n\t\t\t\t}\n\t\t\t\tnextNode$1.dom = lastNode.dom;\n\t\t\t\tpatch(instance, nextNode$1, parentDom, lifecycle, context, null, null, false);\n\t\t\t\tlastNode.instance = nextNode$1;\n\t\t\t\tif (nextHooksDefined && !isNullOrUndefined(nextHooks.componentDidUpdate)) {\n\t\t\t\t\tnextHooks.componentDidUpdate(lastNode.dom, lastProps, nextProps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchVList(lastVList, nextVList, parentDom, lifecycle, context, instance, isSVG) {\n\t\tvar lastItems = lastVList.items;\n\t\tvar nextItems = nextVList.items;\n\t\tvar pointer = lastVList.pointer;\n\n\t\tnextVList.dom = lastVList.dom;\n\t\tnextVList.pointer = pointer;\n\t\tif (!lastItems !== nextItems) {\n\t\t\tif (isKeyed(lastItems, nextItems)) {\n\t\t\t\tpatchKeyedChildren(lastItems, nextItems, parentDom, lifecycle, context, instance, isSVG, nextVList);\n\t\t\t} else {\n\t\t\t\tpatchNonKeyedChildren(lastItems, nextItems, parentDom, lifecycle, context, instance, isSVG, nextVList);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, parentVList) {\n\t\tvar lastChildrenLength = lastChildren.length;\n\t\tvar nextChildrenLength = nextChildren.length;\n\t\tvar commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n\t\tvar i = 0;\n\n\t\tfor (; i < commonLength; i++) {\n\t\t\tvar lastChild = lastChildren[i];\n\t\t\tvar nextChild = normaliseChild(nextChildren, i);\n\n\t\t\tpatch(lastChild, nextChild, dom, lifecycle, context, instance, isSVG);\n\t\t}\n\t\tif (lastChildrenLength < nextChildrenLength) {\n\t\t\tfor (i = commonLength; i < nextChildrenLength; i++) {\n\t\t\t\tvar child = normaliseChild(nextChildren, i);\n\n\t\t\t\tinsertOrAppend(dom, mount(child, null, lifecycle, context, instance, isSVG), parentVList && parentVList.pointer);\n\t\t\t}\n\t\t} else if (lastChildrenLength > nextChildrenLength) {\n\t\t\tfor (i = commonLength; i < lastChildrenLength; i++) {\n\t\t\t\tremove(lastChildren[i], dom);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction patchVFragment(lastVFragment, nextVFragment) {\n\t\tnextVFragment.dom = lastVFragment.dom;\n\t}\n\n\tfunction patchVText(lastVText, nextVText) {\n\t\tvar nextText = nextVText.text;\n\t\tvar dom = lastVText.dom;\n\n\t\tnextVText.dom = dom;\n\t\tif (lastVText.text !== nextText) {\n\t\t\tdom.nodeValue = nextText;\n\t\t}\n\t}\n\n\tfunction patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, instance, isSVG, parentVList) {\n\t\tvar lastChildrenLength = lastChildren.length;\n\t\tvar nextChildrenLength = nextChildren.length;\n\t\tvar lastEndIndex = lastChildrenLength - 1;\n\t\tvar nextEndIndex = nextChildrenLength - 1;\n\t\tvar lastStartIndex = 0;\n\t\tvar nextStartIndex = 0;\n\t\tvar lastStartNode = null;\n\t\tvar nextStartNode = null;\n\t\tvar nextEndNode = null;\n\t\tvar lastEndNode = null;\n\t\tvar nextNode;\n\n\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\tnextStartNode = nextChildren[nextStartIndex];\n\t\t\tlastStartNode = lastChildren[lastStartIndex];\n\n\t\t\tif (nextStartNode.key !== lastStartNode.key) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpatchVNode(lastStartNode, nextStartNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\tnextStartIndex++;\n\t\t\tlastStartIndex++;\n\t\t}\n\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\tnextEndNode = nextChildren[nextEndIndex];\n\t\t\tlastEndNode = lastChildren[lastEndIndex];\n\n\t\t\tif (nextEndNode.key !== lastEndNode.key) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpatchVNode(lastEndNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\tnextEndIndex--;\n\t\t\tlastEndIndex--;\n\t\t}\n\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\tnextEndNode = nextChildren[nextEndIndex];\n\t\t\tlastStartNode = lastChildren[lastStartIndex];\n\n\t\t\tif (nextEndNode.key !== lastStartNode.key) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextNode = (nextEndIndex + 1 < nextChildrenLength) ? nextChildren[nextEndIndex + 1].dom : null;\n\t\t\tpatchVNode(lastStartNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\tinsertOrAppend(dom, nextEndNode.dom, nextNode);\n\t\t\tnextEndIndex--;\n\t\t\tlastStartIndex++;\n\t\t}\n\t\twhile (lastStartIndex <= lastEndIndex && nextStartIndex <= nextEndIndex) {\n\t\t\tnextStartNode = nextChildren[nextStartIndex];\n\t\t\tlastEndNode = lastChildren[lastEndIndex];\n\n\t\t\tif (nextStartNode.key !== lastEndNode.key) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnextNode = lastChildren[lastStartIndex].dom;\n\t\t\tpatchVNode(lastEndNode, nextStartNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\tinsertOrAppend(dom, nextStartNode.dom, nextNode);\n\t\t\tnextStartIndex++;\n\t\t\tlastEndIndex--;\n\t\t}\n\n\t\tif (lastStartIndex > lastEndIndex) {\n\t\t\tif (nextStartIndex <= nextEndIndex) {\n\t\t\t\tnextNode = (nextEndIndex + 1 < nextChildrenLength) ? nextChildren[nextEndIndex + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\tfor (; nextStartIndex <= nextEndIndex; nextStartIndex++) {\n\t\t\t\t\tinsertOrAppend(dom, mount(nextChildren[nextStartIndex], null, lifecycle, context, instance, isSVG), nextNode);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nextStartIndex > nextEndIndex) {\n\t\t\twhile (lastStartIndex <= lastEndIndex) {\n\t\t\t\tremove(lastChildren[lastStartIndex++], dom);\n\t\t\t}\n\t\t} else {\n\t\t\tvar aLength = lastEndIndex - lastStartIndex + 1;\n\t\t\tvar bLength = nextEndIndex - nextStartIndex + 1;\n\t\t\tvar sources = new Array(bLength);\n\n\t\t\t// Mark all nodes as inserted.\n\t\t\tvar i;\n\t\t\tfor (i = 0; i < bLength; i++) {\n\t\t\t\tsources[i] = -1;\n\t\t\t}\n\t\t\tvar moved = false;\n\t\t\tvar removeOffset = 0;\n\t\t\tvar lastTarget = 0;\n\t\t\tvar index;\n\t\t\tvar removed = true;\n\t\t\tvar k = 0;\n\n\t\t\tif ((bLength <= 4) || (aLength * bLength <= 16)) {\n\t\t\t\tfor (i = lastStartIndex; i <= lastEndIndex; i++) {\n\t\t\t\t\tremoved = true;\n\t\t\t\t\tlastEndNode = lastChildren[i];\n\t\t\t\t\tif (k < bLength) {\n\t\t\t\t\t\tfor (index = nextStartIndex; index <= nextEndIndex; index++) {\n\t\t\t\t\t\t\tnextEndNode = nextChildren[index];\n\t\t\t\t\t\t\tif (lastEndNode.key === nextEndNode.key) {\n\t\t\t\t\t\t\t\tsources[index - nextStartIndex] = i;\n\n\t\t\t\t\t\t\t\tif (lastTarget > index) {\n\t\t\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlastTarget = index;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpatchVNode(lastEndNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t\tremoved = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (removed) {\n\t\t\t\t\t\tremove(lastEndNode, dom);\n\t\t\t\t\t\tremoveOffset++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar prevItemsMap = new Map();\n\n\t\t\t\tfor (i = nextStartIndex; i <= nextEndIndex; i++) {\n\t\t\t\t\tprevItemsMap.set(nextChildren[i].key, i);\n\t\t\t\t}\n\t\t\t\tfor (i = lastStartIndex; i <= lastEndIndex; i++) {\n\t\t\t\t\tremoved = true;\n\t\t\t\t\tlastEndNode = lastChildren[i];\n\n\t\t\t\t\tif (k < nextChildrenLength) {\n\t\t\t\t\t\tindex = prevItemsMap.get(lastEndNode.key);\n\n\t\t\t\t\t\tif (index !== undefined) {\n\t\t\t\t\t\t\tnextEndNode = nextChildren[index];\n\t\t\t\t\t\t\tsources[index - nextStartIndex] = i;\n\t\t\t\t\t\t\tif (lastTarget > index) {\n\t\t\t\t\t\t\t\tmoved = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlastTarget = index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpatchVNode(lastEndNode, nextEndNode, dom, lifecycle, context, instance, isSVG, false);\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tremoved = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (removed) {\n\t\t\t\t\t\tremove(lastEndNode, dom);\n\t\t\t\t\t\tremoveOffset++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar pos;\n\t\t\tif (moved) {\n\t\t\t\tvar seq = lis_algorithm(sources);\n\t\t\t\tindex = seq.length - 1;\n\t\t\t\tfor (i = bLength - 1; i >= 0; i--) {\n\t\t\t\t\tif (sources[i] === -1) {\n\t\t\t\t\t\tpos = i + nextStartIndex;\n\t\t\t\t\t\tnextNode = (pos + 1 < nextChildrenLength) ? nextChildren[pos + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\t\tinsertOrAppend(dom, mount(nextChildren[pos], null, lifecycle, context, instance, isSVG), nextNode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (index < 0 || i !== seq[index]) {\n\t\t\t\t\t\t\tpos = i + nextStartIndex;\n\t\t\t\t\t\t\tnextNode = (pos + 1 < nextChildrenLength) ? nextChildren[pos + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\t\t\tinsertOrAppend(dom, nextChildren[pos].dom, nextNode);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (aLength - removeOffset !== bLength) {\n\t\t\t\tfor (i = bLength - 1; i >= 0; i--) {\n\t\t\t\t\tif (sources[i] === -1) {\n\t\t\t\t\t\tpos = i + nextStartIndex;\n\t\t\t\t\t\tnextNode = (pos + 1 < nextChildrenLength) ? nextChildren[pos + 1].dom : parentVList && parentVList.pointer;\n\t\t\t\t\t\tinsertOrAppend(dom, mount(nextChildren[pos], null, lifecycle, context, instance, isSVG), nextNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n\tfunction lis_algorithm(a) {\n\t\tvar p = a.slice(0);\n\t\tvar result = [];\n\t\tresult.push(0);\n\t\tvar i;\n\t\tvar j;\n\t\tvar u;\n\t\tvar v;\n\t\tvar c;\n\n\t\tfor (i = 0; i < a.length; i++) {\n\t\t\tif (a[i] === -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tj = result[result.length - 1];\n\t\t\tif (a[j] < a[i]) {\n\t\t\t\tp[i] = j;\n\t\t\t\tresult.push(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tu = 0;\n\t\t\tv = result.length - 1;\n\n\t\t\twhile (u < v) {\n\t\t\t\tc = ((u + v) / 2) | 0;\n\t\t\t\tif (a[result[c]] < a[i]) {\n\t\t\t\t\tu = c + 1;\n\t\t\t\t} else {\n\t\t\t\t\tv = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a[i] < a[result[u]]) {\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tp[i] = result[u - 1];\n\t\t\t\t}\n\t\t\t\tresult[u] = i;\n\t\t\t}\n\t\t}\n\n\t\tu = result.length;\n\t\tv = result[u - 1];\n\n\t\twhile (u-- > 0) {\n\t\t\tresult[u] = v;\n\t\t\tv = p[v];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tvar screenWidth = isBrowser && window.screen.width;\n\tvar screenHeight = isBrowser && window.screen.height;\n\tvar scrollX = 0;\n\tvar scrollY = 0;\n\tvar lastScrollTime = 0;\n\n\tif (isBrowser) {\n\t\twindow.onscroll = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\n\t\twindow.resize = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tscreenWidth = window.screen.width;\n\t\t\tscreenHeight = window.screen.height;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\t}\n\n\tfunction Lifecycle() {\n\t\tthis._listeners = [];\n\t\tthis.scrollX = null;\n\t\tthis.scrollY = null;\n\t\tthis.screenHeight = screenHeight;\n\t\tthis.screenWidth = screenWidth;\n\t}\n\n\tLifecycle.prototype = {\n\t\trefresh: function refresh() {\n\t\t\tthis.scrollX = isBrowser && window.scrollX;\n\t\t\tthis.scrollY = isBrowser && window.scrollY;\n\t\t},\n\t\taddListener: function addListener(callback) {\n\t\t\tthis._listeners.push(callback);\n\t\t},\n\t\ttrigger: function trigger() {\n\t\t\tvar this$1 = this;\n\n\t\t\tfor (var i = 0; i < this._listeners.length; i++) {\n\t\t\t\tthis$1._listeners[i]();\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction handleLazyAttached(node, lifecycle, dom) {\n\t\tlifecycle.addListener(function () {\n\t\t\tvar rect = dom.getBoundingClientRect();\n\n\t\t\tif (lifecycle.scrollY === null) {\n\t\t\t\tlifecycle.refresh();\n\t\t\t}\n\t\t\tnode.clipData = {\n\t\t\t\ttop: rect.top + lifecycle.scrollY,\n\t\t\t\tleft: rect.left + lifecycle.scrollX,\n\t\t\t\tbottom: rect.bottom + lifecycle.scrollY,\n\t\t\t\tright: rect.right + lifecycle.scrollX,\n\t\t\t\tpending: false\n\t\t\t};\n\t\t});\n\t}\n\n\tfunction hydrateChild(child, childNodes, counter, parentDom, lifecycle, context, instance) {\n\t\tvar domNode = childNodes[counter.i];\n\n\t\tif (isVText(child)) {\n\t\t\tvar text = child.text;\n\n\t\t\tchild.dom = domNode;\n\t\t\tif (domNode.nodeType === 3 && text !== '') {\n\t\t\t\tdomNode.nodeValue = text;\n\t\t\t} else {\n\t\t\t\tvar newDomNode = mountVText(text);\n\n\t\t\t\treplaceNode(parentDom, newDomNode, domNode);\n\t\t\t\tchildNodes.splice(childNodes.indexOf(domNode), 1, newDomNode);\n\t\t\t\tchild.dom = newDomNode;\n\t\t\t}\n\t\t} else if (isVPlaceholder(child)) {\n\t\t\tchild.dom = domNode;\n\t\t} else if (isVList(child)) {\n\t\t\tvar items = child.items;\n\n\t\t\t// this doesn't really matter, as it won't be used again, but it's what it should be given the purpose of VList\n\t\t\tchild.dom = document.createDocumentFragment();\n\t\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\t\tvar rebuild = hydrateChild(normaliseChild(items, i), childNodes, counter, parentDom, lifecycle, context, instance);\n\n\t\t\t\tif (rebuild) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// at the end of every VList, there should be a \"pointer\". It's an empty TextNode used for tracking the VList\n\t\t\tvar pointer = childNodes[counter.i++];\n\n\t\t\tif (pointer && pointer.nodeType === 3) {\n\t\t\t\tchild.pointer = pointer;\n\t\t\t} else {\n\t\t\t\t// there is a problem, we need to rebuild this tree\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tvar rebuild$1 = hydrateNode(child, domNode, parentDom, lifecycle, context, instance, false);\n\n\t\t\tif (rebuild$1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcounter.i++;\n\t}\n\n\tfunction getChildNodesWithoutComments(domNode) {\n\t\tvar childNodes = [];\n\t\tvar rawChildNodes = domNode.childNodes;\n\t\tvar length = rawChildNodes.length;\n\t\tvar i = 0;\n\n\t\twhile (i < length) {\n\t\t\tvar rawChild = rawChildNodes[i];\n\n\t\t\tif (rawChild.nodeType === 8) {\n\t\t\t\tif (rawChild.data === '!') {\n\t\t\t\t\tvar placeholder = document.createTextNode('');\n\n\t\t\t\t\tdomNode.replaceChild(placeholder, rawChild);\n\t\t\t\t\tchildNodes.push(placeholder);\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tdomNode.removeChild(rawChild);\n\t\t\t\t\tlength--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchildNodes.push(rawChild);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn childNodes;\n\t}\n\n\tfunction hydrateComponent(node, Component, props, hooks, children, domNode, parentDom, lifecycle, context, lastInstance, isRoot) {\n\t\tprops = addChildrenToProps(children, props);\n\n\t\tif (isStatefulComponent(Component)) {\n\t\t\tvar instance = node.instance = new Component(props);\n\n\t\t\tinstance._patch = patch;\n\t\t\tif (!isNullOrUndefined(lastInstance) && props.ref) {\n\t\t\t\tmountRef(lastInstance, props.ref, instance);\n\t\t\t}\n\t\t\tvar childContext = instance.getChildContext();\n\n\t\t\tif (!isNullOrUndefined(childContext)) {\n\t\t\t\tcontext = Object.assign({}, context, childContext);\n\t\t\t}\n\t\t\tinstance.context = context;\n\t\t\tinstance._unmounted = false;\n\t\t\tinstance._parentNode = node;\n\t\t\tif (lastInstance) {\n\t\t\t\tinstance._parentComponent = lastInstance;\n\t\t\t}\n\t\t\tinstance._pendingSetState = true;\n\t\t\tinstance.componentWillMount();\n\t\t\tvar nextNode = instance.render();\n\n\t\t\tinstance._pendingSetState = false;\n\t\t\tif (isInvalidNode(nextNode)) {\n\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t}\n\t\t\thydrateNode(nextNode, domNode, parentDom, lifecycle, context, instance, isRoot);\n\t\t\tinstance._lastNode = nextNode;\n\t\t\tinstance.componentDidMount();\n\n\t\t} else {\n\t\t\tvar instance$1 = node.instance = Component(props);\n\n\t\t\tif (!isNullOrUndefined(hooks)) {\n\t\t\t\tif (!isNullOrUndefined(hooks.componentWillMount)) {\n\t\t\t\t\thooks.componentWillMount(null, props);\n\t\t\t\t}\n\t\t\t\tif (!isNullOrUndefined(hooks.componentDidMount)) {\n\t\t\t\t\tlifecycle.addListener(function () {\n\t\t\t\t\t\thooks.componentDidMount(domNode, props);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hydrateNode(instance$1, domNode, parentDom, lifecycle, context, instance$1, isRoot);\n\t\t}\n\t}\n\n\tfunction hydrateNode(node, domNode, parentDom, lifecycle, context, instance, isRoot) {\n\t\tvar bp = node.bp;\n\t\tvar tag = node.tag || bp.tag;\n\n\t\tif (isFunction(tag)) {\n\t\t\tnode.dom = domNode;\n\t\t\thydrateComponent(node, tag, node.attrs || {}, node.hooks, node.children, domNode, parentDom, lifecycle, context, instance, isRoot);\n\t\t} else {\n\t\t\tif (\n\t\t\t\tdomNode.nodeType !== 1 ||\n\t\t\t\ttag !== domNode.tagName.toLowerCase()\n\t\t\t) {\n\t\t\t\t// TODO remake node\n\t\t\t} else {\n\t\t\t\tnode.dom = domNode;\n\t\t\t\tvar hooks = node.hooks;\n\n\t\t\t\tif ((bp && bp.hasHooks === true) || !isNullOrUndefined(hooks)) {\n\t\t\t\t\thandleAttachedHooks(hooks, lifecycle, domNode);\n\t\t\t\t}\n\t\t\t\tvar children = node.children;\n\n\t\t\t\tif (!isNullOrUndefined(children)) {\n\t\t\t\t\tif (isStringOrNumber(children)) {\n\t\t\t\t\t\tif (domNode.textContent !== children) {\n\t\t\t\t\t\t\tdomNode.textContent = children;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar childNodes = getChildNodesWithoutComments(domNode);\n\t\t\t\t\t\tvar counter = { i: 0 };\n\t\t\t\t\t\tvar rebuild = false;\n\n\t\t\t\t\t\tif (isArray(children)) {\n\t\t\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\t\t\trebuild = hydrateChild(normaliseChild(children, i), childNodes, counter, domNode, lifecycle, context, instance);\n\n\t\t\t\t\t\t\t\tif (rebuild) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (childNodes.length === 1) {\n\t\t\t\t\t\t\t\trebuild = hydrateChild(children, childNodes, counter, domNode, lifecycle, context, instance);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trebuild = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (rebuild) {\n\t\t\t\t\t\t\t// TODO scrap children and rebuild again\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar className = node.className;\n\t\t\t\tvar style = node.style;\n\n\t\t\t\tif (!isNullOrUndefined(className)) {\n\t\t\t\t\tdomNode.className = className;\n\t\t\t\t}\n\t\t\t\tif (!isNullOrUndefined(style)) {\n\t\t\t\t\tpatchStyle(null, style, domNode);\n\t\t\t\t}\n\t\t\t\tif (bp && bp.hasAttrs === true) {\n\t\t\t\t\tmountBlueprintAttrs(node, bp, domNode, instance);\n\t\t\t\t} else {\n\t\t\t\t\tvar attrs = node.attrs;\n\n\t\t\t\t\tif (!isNullOrUndefined(attrs)) {\n\t\t\t\t\t\thandleSelects(node);\n\t\t\t\t\t\tmountAttributes(node, attrs, Object.keys(attrs), domNode, instance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bp && bp.hasEvents === true) {\n\t\t\t\t\tmountBlueprintEvents(node, bp, domNode);\n\t\t\t\t} else {\n\t\t\t\t\tvar events = node.events;\n\n\t\t\t\t\tif (!isNullOrUndefined(events)) {\n\t\t\t\t\t\tmountEvents(events, Object.keys(events), domNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvar documetBody = isBrowser ? document.body : null;\n\n\tfunction hydrate(node, parentDom, lifecycle) {\n\t\tif (parentDom && parentDom.nodeType === 1) {\n\t\t\tvar rootNode = parentDom.querySelector('[data-infernoroot]');\n\n\t\t\tif (rootNode && rootNode.parentNode === parentDom) {\n\t\t\t\thydrateNode(node, rootNode, parentDom, lifecycle, {}, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t// clear parentDom, unless it's document.body\n\t\tif (parentDom !== documetBody) {\n\t\t\tparentDom.textContent = '';\n\t\t} else {\n\t\t\tconsole.warn('Inferno Warning: rendering to the \"document.body\" is dangerous! Use a dedicated container element instead.');\n\t\t}\n\t\treturn false;\n\t}\n\n\tvar roots = new Map();\n\tvar componentToDOMNodeMap = new Map();\n\n\tfunction findDOMNode(domNode) {\n\t\treturn componentToDOMNodeMap.get(domNode) || null;\n\t}\n\n\tfunction render(input, parentDom) {\n\t\tvar root = roots.get(parentDom);\n\t\tvar lifecycle = new Lifecycle();\n\n\t\tif (isUndefined(root)) {\n\t\t\tif (!isInvalidNode(input)) {\n\t\t\t\tif (!hydrate(input, parentDom, lifecycle)) {\n\t\t\t\t\tmount(input, parentDom, lifecycle, {}, null, false);\n\t\t\t\t}\n\t\t\t\tlifecycle.trigger();\n\t\t\t\troots.set(parentDom, { input: input });\n\t\t\t}\n\t\t} else {\n\t\t\tvar activeNode = getActiveNode();\n\t\t\tvar nextInput = patch(root.input, input, parentDom, lifecycle, {}, null, false);\n\n\t\t\tlifecycle.trigger();\n\t\t\tif (isNull(input)) {\n\t\t\t\troots.delete(parentDom);\n\t\t\t}\n\t\t\troot.input = nextInput;\n\t\t\tresetActiveNode(activeNode);\n\t\t}\n\t}\n\n\tvar index = {\n\t\trender: render,\n\t\tfindDOMNode: findDOMNode,\n\t\tmount: mount,\n\t\tpatch: patch,\n\t\tunmount: unmount\n\t};\n\n\treturn index;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inferno/dist/inferno-dom.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('inferno/dist/inferno-component');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inferno-component/inferno-component.js\n ** module id = 3\n ** module chunks = 0\n **/","/*!\n * inferno-component v0.7.25\n * (c) 2016 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.InfernoComponent = factory());\n}(this, function () { 'use strict';\n\n\tvar NO_RENDER = 'NO_RENDER';\n\n\t// Runs only once in applications lifetime\n\tvar isBrowser = typeof window !== 'undefined' && window.document;\n\n\tfunction isNullOrUndefined(obj) {\n\t\treturn isUndefined(obj) || isNull(obj);\n\t}\n\n\tfunction isNull(obj) {\n\t\treturn obj === null;\n\t}\n\n\tfunction isUndefined(obj) {\n\t\treturn obj === undefined;\n\t}\n\n\tfunction VPlaceholder() {\n\t\tthis.placeholder = true;\n\t\tthis.dom = null;\n\t}\n\n\tfunction createVPlaceholder() {\n\t\treturn new VPlaceholder();\n\t}\n\n\tvar documetBody = isBrowser ? document.body : null;\n\n\tfunction constructDefaults(string, object, value) {\n\t\t/* eslint no-return-assign: 0 */\n\t\tstring.split(',').forEach(function (i) { return object[i] = value; });\n\t}\n\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\tvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\n\tvar strictProps = {};\n\tvar booleanProps = {};\n\tvar namespaces = {};\n\tvar isUnitlessNumber = {};\n\n\tconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\n\tconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\n\tconstructDefaults('volume,value', strictProps, true);\n\tconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,selected,readonly,multiple,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\n\tconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\n\tvar screenWidth = isBrowser && window.screen.width;\n\tvar screenHeight = isBrowser && window.screen.height;\n\tvar scrollX = 0;\n\tvar scrollY = 0;\n\tvar lastScrollTime = 0;\n\n\tif (isBrowser) {\n\t\twindow.onscroll = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\n\t\twindow.resize = function () {\n\t\t\tscrollX = window.scrollX;\n\t\t\tscrollY = window.scrollY;\n\t\t\tscreenWidth = window.screen.width;\n\t\t\tscreenHeight = window.screen.height;\n\t\t\tlastScrollTime = performance.now();\n\t\t};\n\t}\n\n\tfunction Lifecycle() {\n\t\tthis._listeners = [];\n\t\tthis.scrollX = null;\n\t\tthis.scrollY = null;\n\t\tthis.screenHeight = screenHeight;\n\t\tthis.screenWidth = screenWidth;\n\t}\n\n\tLifecycle.prototype = {\n\t\trefresh: function refresh() {\n\t\t\tthis.scrollX = isBrowser && window.scrollX;\n\t\t\tthis.scrollY = isBrowser && window.scrollY;\n\t\t},\n\t\taddListener: function addListener(callback) {\n\t\t\tthis._listeners.push(callback);\n\t\t},\n\t\ttrigger: function trigger() {\n\t\t\tvar this$1 = this;\n\n\t\t\tfor (var i = 0; i < this._listeners.length; i++) {\n\t\t\t\tthis$1._listeners[i]();\n\t\t\t}\n\t\t}\n\t};\n\n\tvar noOp = 'Inferno Error: Can only update a mounted or mounting component. This usually means you called setState() or forceUpdate() on an unmounted component. This is a no-op.';\n\n\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\tfunction getActiveNode() {\n\t\treturn document.activeElement;\n\t}\n\n\t// Copy of the util from dom/util, otherwise it makes massive bundles\n\tfunction resetActiveNode(activeNode) {\n\t\tif (activeNode !== document.body && document.activeElement !== activeNode) {\n\t\t\tactiveNode.focus(); // TODO: verify are we doing new focus event, if user has focus listener this might trigger it\n\t\t}\n\t}\n\n\tfunction queueStateChanges(component, newState, callback) {\n\t\tfor (var stateKey in newState) {\n\t\t\tcomponent._pendingState[stateKey] = newState[stateKey];\n\t\t}\n\t\tif (!component._pendingSetState) {\n\t\t\tcomponent._pendingSetState = true;\n\t\t\tapplyState(component, false, callback);\n\t\t} else {\n\t\t\tcomponent.state = Object.assign({}, component.state, component._pendingState);\n\t\t\tcomponent._pendingState = {};\n\t\t}\n\t}\n\n\tfunction applyState(component, force, callback) {\n\t\tif ((!component._deferSetState || force) && !component._blockRender) {\n\t\t\tcomponent._pendingSetState = false;\n\t\t\tvar pendingState = component._pendingState;\n\t\t\tvar prevState = component.state;\n\t\t\tvar nextState = Object.assign({}, prevState, pendingState);\n\t\t\tvar props = component.props;\n\n\t\t\tcomponent._pendingState = {};\n\t\t\tvar nextNode = component._updateComponent(prevState, nextState, props, props, force);\n\n\t\t\tif (nextNode === NO_RENDER) {\n\t\t\t\tnextNode = component._lastNode;\n\t\t\t} else if (isNullOrUndefined(nextNode)) {\n\t\t\t\tnextNode = createVPlaceholder();\n\t\t\t}\n\t\t\tvar lastNode = component._lastNode;\n\t\t\tvar parentDom = lastNode.dom.parentNode;\n\t\t\tvar activeNode = getActiveNode();\n\t\t\tvar subLifecycle = new Lifecycle();\n\n\t\t\tcomponent._patch(lastNode, nextNode, parentDom, subLifecycle, component.context, component, null);\n\t\t\tcomponent._lastNode = nextNode;\n\t\t\tcomponent._componentToDOMNodeMap.set(component, nextNode.dom);\n\t\t\tcomponent._parentNode.dom = nextNode.dom;\n\t\t\tcomponent.componentDidUpdate(props, prevState);\n\t\t\tsubLifecycle.trigger();\n\t\t\tif (!isNullOrUndefined(callback)) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\tresetActiveNode(activeNode);\n\t\t}\n\t}\n\n\tvar Component = function Component(props, context) {\n\t\tif ( context === void 0 ) context = {};\n\n\t\t/** @type {object} */\n\t\tthis.props = props || {};\n\n\t\t/** @type {object} */\n\t\tthis.state = {};\n\n\t\t/** @type {object} */\n\t\tthis.refs = {};\n\t\tthis._blockRender = false;\n\t\tthis._blockSetState = false;\n\t\tthis._deferSetState = false;\n\t\tthis._pendingSetState = false;\n\t\tthis._pendingState = {};\n\t\tthis._parentNode = null;\n\t\tthis._lastNode = null;\n\t\tthis._unmounted = true;\n\t\tthis.context = context;\n\t\tthis._patch = null;\n\t\tthis._parentComponent = null;\n\t\tthis._componentToDOMNodeMap = null;\n\t};\n\n\tComponent.prototype.render = function render () {\n\t};\n\n\tComponent.prototype.forceUpdate = function forceUpdate (callback) {\n\t\tif (this._unmounted) {\n\t\t\tthrow Error(noOp);\n\t\t}\n\t\tapplyState(this, true, callback);\n\t};\n\n\tComponent.prototype.setState = function setState (newState, callback) {\n\t\tif (this._unmounted) {\n\t\t\tthrow Error(noOp);\n\t\t}\n\t\tif (this._blockSetState === false) {\n\t\t\tqueueStateChanges(this, newState, callback);\n\t\t} else {\n\t\t\tthrow Error('Inferno Warning: Cannot update state via setState() in componentWillUpdate()');\n\t\t}\n\t};\n\n\tComponent.prototype.componentDidMount = function componentDidMount () {\n\t};\n\n\tComponent.prototype.componentWillMount = function componentWillMount () {\n\t};\n\n\tComponent.prototype.componentWillUnmount = function componentWillUnmount () {\n\t};\n\n\tComponent.prototype.componentDidUpdate = function componentDidUpdate () {\n\t};\n\n\tComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate () {\n\t\treturn true;\n\t};\n\n\tComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps () {\n\t};\n\n\tComponent.prototype.componentWillUpdate = function componentWillUpdate () {\n\t};\n\n\tComponent.prototype.getChildContext = function getChildContext () {\n\t};\n\n\tComponent.prototype._updateComponent = function _updateComponent (prevState, nextState, prevProps, nextProps, force) {\n\t\tif (this._unmounted === true) {\n\t\t\tthis._unmounted = false;\n\t\t\treturn false;\n\t\t}\n\t\tif (!isNullOrUndefined(nextProps) && isNullOrUndefined(nextProps.children)) {\n\t\t\tnextProps.children = prevProps.children;\n\t\t}\n\t\tif (prevProps !== nextProps || prevState !== nextState || force) {\n\t\t\tif (prevProps !== nextProps) {\n\t\t\t\tthis._blockRender = true;\n\t\t\t\tthis.componentWillReceiveProps(nextProps);\n\t\t\t\tthis._blockRender = false;\n\t\t\t\tif (this._pendingSetState) {\n\t\t\t\t\tnextState = Object.assign({}, nextState, this._pendingState);\n\t\t\t\t\tthis._pendingSetState = false;\n\t\t\t\t\tthis._pendingState = {};\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar shouldUpdate = this.shouldComponentUpdate(nextProps, nextState);\n\n\t\t\tif (shouldUpdate !== false || force) {\n\t\t\t\tthis._blockSetState = true;\n\t\t\t\tthis.componentWillUpdate(nextProps, nextState);\n\t\t\t\tthis._blockSetState = false;\n\t\t\t\tthis.props = nextProps;\n\t\t\t\tthis.state = nextState;\n\t\t\t\treturn this.render();\n\t\t\t}\n\t\t}\n\t\treturn NO_RENDER;\n\t};\n\n\treturn Component;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inferno/dist/inferno-component.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = require('inferno/dist/inferno-create-element');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inferno-create-element/inferno-create-element.js\n ** module id = 5\n ** module chunks = 0\n **/","/*!\n * inferno-create-element v0.7.25\n * (c) 2016 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.InfernoCreateElement = factory());\n}(this, function () { 'use strict';\n\n\tfunction isArray(obj) {\n\t\treturn obj instanceof Array;\n\t}\n\n\tfunction isNullOrUndefined(obj) {\n\t\treturn isUndefined(obj) || isNull(obj);\n\t}\n\n\tfunction isInvalidNode(obj) {\n\t\treturn isNull(obj) || obj === false || obj === true || isUndefined(obj);\n\t}\n\n\tfunction isFunction(obj) {\n\t\treturn typeof obj === 'function';\n\t}\n\n\tfunction isAttrAnEvent$1(attr) {\n\t\treturn attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n\t}\n\n\tfunction isNull(obj) {\n\t\treturn obj === null;\n\t}\n\n\tfunction isUndefined(obj) {\n\t\treturn obj === undefined;\n\t}\n\n\tfunction isAttrAHook$1(hook) {\n\t\treturn hook === 'onCreated'\n\t\t\t|| hook === 'onAttached'\n\t\t\t|| hook === 'onWillDetach'\n\t\t\t|| hook === 'onWillUpdate'\n\t\t\t|| hook === 'onDidUpdate';\n\t}\n\n\tfunction isAttrAComponentHook$1(hook) {\n\t\treturn hook === 'onComponentWillMount'\n\t\t\t|| hook === 'onComponentDidMount'\n\t\t\t|| hook === 'onComponentWillUnmount'\n\t\t\t|| hook === 'onComponentShouldUpdate'\n\t\t\t|| hook === 'onComponentWillUpdate'\n\t\t\t|| hook === 'onComponentDidUpdate';\n\t}\n\n\tfunction VNode(blueprint) {\n\t\tthis.bp = blueprint;\n\t\tthis.dom = null;\n\t\tthis.instance = null;\n\t\tthis.tag = null;\n\t\tthis.children = null;\n\t\tthis.style = null;\n\t\tthis.className = null;\n\t\tthis.attrs = null;\n\t\tthis.events = null;\n\t\tthis.hooks = null;\n\t\tthis.key = null;\n\t\tthis.clipData = null;\n\t}\n\n\tVNode.prototype = {\n\t\tsetAttrs: function setAttrs(attrs) {\n\t\t\tthis.attrs = attrs;\n\t\t\treturn this;\n\t\t},\n\t\tsetTag: function setTag(tag) {\n\t\t\tthis.tag = tag;\n\t\t\treturn this;\n\t\t},\n\t\tsetStyle: function setStyle(style) {\n\t\t\tthis.style = style;\n\t\t\treturn this;\n\t\t},\n\t\tsetClassName: function setClassName(className) {\n\t\t\tthis.className = className;\n\t\t\treturn this;\n\t\t},\n\t\tsetChildren: function setChildren(children) {\n\t\t\tthis.children = children;\n\t\t\treturn this;\n\t\t},\n\t\tsetHooks: function setHooks(hooks) {\n\t\t\tthis.hooks = hooks;\n\t\t\treturn this;\n\t\t},\n\t\tsetEvents: function setEvents(events) {\n\t\t\tthis.events = events;\n\t\t\treturn this;\n\t\t},\n\t\tsetKey: function setKey(key) {\n\t\t\tthis.key = key;\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tfunction createVNode(bp) {\n\t\treturn new VNode(bp);\n\t}\n\n\tfunction createAttrsAndEvents(props, tag) {\n\t\tvar events = null;\n\t\tvar hooks = null;\n\t\tvar attrs = null;\n\t\tvar className = null;\n\t\tvar style = null;\n\n\t\tif (!isNullOrUndefined(props)) {\n\t\t\tif (isArray(props)) {\n\t\t\t\treturn props;\n\t\t\t}\n\t\t\tfor (var prop in props) {\n\t\t\t\tif (prop === 'className') {\n\t\t\t\t\tclassName = props[prop];\n\t\t\t\t} else if (prop === 'style') {\n\t\t\t\t\tstyle = props[prop];\n\t\t\t\t} else if (isAttrAHook$1(prop) && !isFunction(tag)) {\n\t\t\t\t\tif (isNullOrUndefined(hooks)) {\n\t\t\t\t\t\thooks = {};\n\t\t\t\t\t}\n\t\t\t\t\thooks[prop.substring(2).toLowerCase()] = props[prop];\n\t\t\t\t\tdelete props[prop];\n\t\t\t\t} else if (isAttrAnEvent$1(prop) && !isFunction(tag)) {\n\t\t\t\t\tif (isNullOrUndefined(events)) {\n\t\t\t\t\t\tevents = {};\n\t\t\t\t\t}\n\t\t\t\t\tevents[prop.toLowerCase()] = props[prop];\n\t\t\t\t\tdelete props[prop];\n\t\t\t\t} else if (isAttrAComponentHook$1(prop) && isFunction(tag)) {\n\t\t\t\t\tif (isNullOrUndefined(hooks)) {\n\t\t\t\t\t\thooks = {};\n\t\t\t\t\t}\n\t\t\t\t\thooks['c' + prop.substring(3)] = props[prop];\n\t\t\t\t\tdelete props[prop];\n\t\t\t\t} else if (!isFunction(tag)) {\n\t\t\t\t\tif (isNullOrUndefined(attrs)) {\n\t\t\t\t\t\tattrs = {};\n\t\t\t\t\t}\n\t\t\t\t\tattrs[prop] = props[prop];\n\t\t\t\t} else {\n\t\t\t\t\tattrs = props;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { attrs: attrs, events: events, className: className, style: style, hooks: hooks };\n\t}\n\n\tfunction createChild(ref) {\n\t\tvar tag = ref.tag;\n\t\tvar attrs = ref.attrs;\n\t\tvar children = ref.children;\n\t\tvar className = ref.className;\n\t\tvar style = ref.style;\n\t\tvar events = ref.events;\n\t\tvar hooks = ref.hooks;\n\n\t\tif (tag === undefined && !isNullOrUndefined(attrs) && !attrs.tpl && !isNullOrUndefined(children) && children.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tvar key = !isNullOrUndefined(attrs) && !isNullOrUndefined(attrs.key) ? attrs.key : undefined;\n\n\t\tif (!isNullOrUndefined(children) && children.length === 0) {\n\t\t\tchildren = null;\n\t\t} else if (!isInvalidNode(children)) {\n\t\t\tchildren = isArray(children) && children.length === 1 ? createChildren(children[0]) : createChildren(children);\n\t\t}\n\n\t\tif (key !== undefined) {\n\t\t\tdelete attrs.key;\n\t\t}\n\t\tvar attrsAndEvents = createAttrsAndEvents(attrs, tag);\n\t\tvar vNode = createVNode();\n\n\t\tclassName = className || attrsAndEvents.className;\n\t\tstyle = style || attrsAndEvents.style;\n\n\t\tvNode.tag = tag || null;\n\t\tvNode.attrs = attrsAndEvents.attrs || null;\n\t\tvNode.events = attrsAndEvents.events || events;\n\t\tvNode.hooks = attrsAndEvents.hooks || hooks;\n\t\tvNode.children = children === undefined ? null : children;\n\t\tvNode.key = key === undefined ? null : key;\n\t\tvNode.className = className === undefined ? null : className;\n\t\tvNode.style = style === undefined ? null : style;\n\n\t\treturn vNode;\n\t}\n\n\tfunction createChildren(children) {\n\t\tvar childrenDefined = !isNullOrUndefined(children);\n\t\tif (childrenDefined && isArray(children)) {\n\t\t\tvar newChildren = [];\n\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar child = children[i];\n\t\t\t\tif (!isNullOrUndefined(child) && typeof child === 'object') {\n\t\t\t\t\tif (isArray(child)) {\n\t\t\t\t\t\tif (child.length > 0) {\n\t\t\t\t\t\t\tnewChildren.push(createChildren(child));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewChildren.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewChildren.push(createChild(child));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewChildren.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn newChildren;\n\t\t} else if (childrenDefined && typeof children === 'object') {\n\t\t\treturn children.dom === undefined ? createChild(children) : children;\n\t\t}\n\t\treturn children;\n\t}\n\n\tfunction createElement(tag, props) {\n\t\tvar children = [], len = arguments.length - 2;\n\t\twhile ( len-- > 0 ) children[ len ] = arguments[ len + 2 ];\n\n\t\treturn createChild({ tag: tag, attrs: props, children: children });\n\t}\n\n\treturn createElement;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inferno/dist/inferno-create-element.js\n ** module id = 6\n ** module chunks = 0\n **/"],"sourceRoot":""}